<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vintage Story Mod-Creator</title>
    <script src="./node_modules/blockly/blockly_compressed.js"></script>
    <script src="./node_modules/blockly/blocks_compressed.js"></script>
    <script src="./node_modules/blockly/javascript_compressed.js"></script>
    <script src="./node_modules/blockly/msg/en.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1e272e, #3498db);
            color: #ecf0f1;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        h1 {
            font-size: 2.5rem;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            animation: fadeIn 1s ease-in;
        }
        .main-container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            gap: 20px;
        }
        .left-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .right-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #blocklyDiv {
            height: 600px;
            width: 100%;
            max-width: 800px;
            border: 2px solid #34495e;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            background: #fff;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 12px 24px;
            font-size: 1.1rem;
            background: #e74c3c;
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background: #c0392b;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        #texturePath {
            width: 300px;
            padding: 10px;
            border: 1px solid #34495e;
            border-radius: 5px;
            background: #2c3e50;
            color: #ecf0f1;
            margin-left: 10px;
            outline: none;
        }
        #textureList {
            padding: 15px;
            border: 2px dashed #34495e;
            border-radius: 10px;
            background: rgba(44, 62, 80, 0.8);
            max-height: 600px;
            overflow-y: auto;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            flex-grow: 1;
        }
        #output {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #34495e;
            border-radius: 10px;
            background: rgba(44, 62, 80, 0.9);
            white-space: pre-wrap;
            width: 100%;
            max-width: 800px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <h1>Vintage Story Mod-Creator</h1>
    <div class="main-container">
        <div class="left-section">
            <div id="blocklyDiv"></div>
            <div class="controls">
                <button onclick="selectTexture()">Textur auswählen</button>
                <input type="text" id="texturePath" readonly placeholder="Keine Textur ausgewählt">
                <button onclick="generateMod()">Mod erstellen & kompilieren</button>
            </div>
            <pre id="output"></pre>
        </div>
        <div class="right-section">
            <div id="textureList">Geladene Texturen:<br></div>
        </div>
    </div>

    <script>
    const fs = require('fs');
    const path = require('path');
    const { ipcRenderer } = require('electron');
    const remote = require('@electron/remote');
    const dialog = remote.dialog;
    const AdmZip = require('adm-zip');
    const { execSync } = require('child_process');

    let selectedTexturePath = null;
    let textureList = [];
    let workspace = null;
    let modConfig = {
        modName: 'mymod2',
        author: 'Mod-Creator User',
        version: '1.0.0',
        description: 'Erstellt mit dem Vintage Story Mod-Creator',
        dependencies: { 'game': '*' }
    };

    try {
        workspace = Blockly.inject('blocklyDiv', {
            toolbox: `
                <xml>
                    <category name="Blöcke" colour="#2ecc71">
                        <block type="vs_new_block"></block>
                        <block type="vs_multiblock"></block>
                        <block type="vs_liquid_block"></block>
                        <block type="vs_plant_block"></block>
                        <block type="vs_crop_block"></block>
                        <block type="vs_door_block"></block>
                        <block type="vs_container_block"></block>
                        <block type="vs_light_source"></block>
                        <block type="vs_rotatable_block"></block>
                        <block type="vs_slab_stairs"></block>
                        <block type="vs_falling_block"></block>
                        <block type="vs_connected_textures"></block>
                    </category>
                    <category name="Items & Werkzeuge" colour="#9b59b6">
                        <block type="vs_new_item"></block>
                        <block type="vs_new_tool"></block>
                        <block type="vs_new_weapon"></block>
                        <block type="vs_new_armor"></block>
                        <block type="vs_item_durability"></block>
                        <block type="vs_tool_mining_speed"></block>
                        <block type="vs_tool_tier"></block>
                        <block type="vs_item_stack_size"></block>
                        <block type="vs_item_attributes"></block>
                        <block type="vs_throwable_item"></block>
                    </category>
                    <category name="Entities & Kreaturen" colour="#e74c3c">
                        <block type="vs_new_entity"></block>
                        <block type="vs_entity_ai"></block>
                        <block type="vs_entity_stats"></block>
                        <block type="vs_entity_drops"></block>
                        <block type="vs_entity_spawn"></block>
                        <block type="vs_entity_animation"></block>
                        <block type="vs_entity_sounds"></block>
                        <block type="vs_entity_taming"></block>
                        <block type="vs_entity_breeding"></block>
                        <block type="vs_entity_mount"></block>
                        <block type="vs_npc_trader"></block>
                        <block type="vs_boss_entity"></block>
                    </category>
                    <category name="Weltgenerierung" colour="#1abc9c">
                        <block type="vs_ore_deposit"></block>
                        <block type="vs_structure_gen"></block>
                        <block type="vs_biome_modifier"></block>
                        <block type="vs_tree_type"></block>
                        <block type="vs_cave_decorator"></block>
                        <block type="vs_surface_deposit"></block>
                        <block type="vs_ruins_generator"></block>
                        <block type="vs_dungeon_gen"></block>
                    </category>
                    <category name="Crafting & Verarbeitung" colour="#f1c40f">
                        <block type="vs_new_recipe"></block>
                        <block type="vs_grid_recipe"></block>
                        <block type="vs_barrel_recipe"></block>
                        <block type="vs_clay_forming"></block>
                        <block type="vs_smithing_recipe"></block>
                        <block type="vs_knapping_recipe"></block>
                        <block type="vs_cooking_recipe"></block>
                        <block type="vs_alloy_recipe"></block>
                        <block type="vs_fuel_type"></block>
                        <block type="vs_drying_recipe"></block>
                        <block type="vs_grinding_recipe"></block>
                    </category>
                    <category name="Sounds & Partikel" colour="#3498db">
                        <block type="vs_custom_sound"></block>
                        <block type="vs_ambient_sound"></block>
                        <block type="vs_particle_effect"></block>
                        <block type="vs_block_particles"></block>
                        <block type="vs_weather_particles"></block>
                        <block type="vs_footstep_sound"></block>
                    </category>
                    <category name="GUI & HUD" colour="#e67e22">
                        <block type="vs_custom_gui"></block>
                        <block type="vs_hud_element"></block>
                        <block type="vs_progress_bar"></block>
                        <block type="vs_inventory_slots"></block>
                        <block type="vs_button_element"></block>
                        <block type="vs_text_input"></block>
                        <block type="vs_dropdown_menu"></block>
                        <block type="vs_tooltip"></block>
                    </category>
                    <category name="Commands & Events" colour="#95a5a6">
                        <block type="vs_chat_command"></block>
                        <block type="vs_keybind"></block>
                        <block type="vs_on_player_join"></block>
                        <block type="vs_on_block_break"></block>
                        <block type="vs_on_entity_death"></block>
                        <block type="vs_on_item_use"></block>
                        <block type="vs_timer_event"></block>
                        <block type="vs_world_tick"></block>
                    </category>
                    <category name="Verhalten" colour="#e67e22">
                        <block type="vs_block_behavior"></block>
                        <block type="vs_block_gui_csharp"></block>
                        <block type="vs_event_handler"></block>
                    </category>
                    <category name="Mechaniken & Systeme" colour="#8e44ad">
                        <block type="vs_temperature_system"></block>
                        <block type="vs_nutrition_type"></block>
                        <block type="vs_skill_system"></block>
                        <block type="vs_experience_gain"></block>
                        <block type="vs_status_effect"></block>
                        <block type="vs_damage_type"></block>
                        <block type="vs_repair_system"></block>
                        <block type="vs_decay_system"></block>
                    </category>
                </xml>
            `,
            trashcan: true,
            scrollbars: true,
            zoom: { controls: true, wheel: true, startScale: 1.0 },
            grid: { spacing: 20, length: 3, colour: '#ccc', snap: true }
        });

        // Validator-Funktionen
        function validateName(newValue) {
            const allowed = /^[a-zA-Z0-9-_]*$/;
            return allowed.test(newValue) ? newValue : newValue.replace(/[^a-zA-Z0-9-_]/g, '');
        }
        function validatePattern(newValue) {
            const allowed = /^[a-zA-Z0-9_,]*$/;
            return allowed.test(newValue) ? newValue : newValue.replace(/[^a-zA-Z0-9_,]/g, '');
        }
        function validateCode(newValue) {
            const allowed = /^[a-zA-Z0-9:_-]*$/;
            return allowed.test(newValue) ? newValue : newValue.replace(/[^a-zA-Z0-9:_-]/g, '');
        }
        function validateText(newValue) {
            const allowed = /^[a-zA-Z0-9\s.,_-]*$/;
            return allowed.test(newValue) ? newValue : newValue.replace(/[^a-zA-Z0-9\s.,_-]/g, '');
        }

        Blockly.Blocks['vs_new_block'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Neuer Block")
                    .appendField(new Blockly.FieldTextInput("myblock", validateName), "NAME");
                this.appendDummyInput()
                    .appendField("Texturtyp")
                    .appendField(new Blockly.FieldDropdown([["Einheitlich", "SINGLE"], ["Sechsseitig", "SIX_SIDED"]]), "TEXTURE_TYPE");
                this.appendDummyInput("singleTexture")
                    .appendField("Textur")
                    .appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput("sixSidedTextures")
                    .appendField("Oben")
                    .appendField(new Blockly.FieldDropdown(getTextureOptions), "TOP");
                this.appendDummyInput("sixSidedTextures")
                    .appendField("Unten")
                    .appendField(new Blockly.FieldDropdown(getTextureOptions), "BOTTOM");
                this.appendDummyInput("sixSidedTextures")
                    .appendField("Norden")
                    .appendField(new Blockly.FieldDropdown(getTextureOptions), "NORTH");
                this.appendDummyInput("sixSidedTextures")
                    .appendField("Süden")
                    .appendField(new Blockly.FieldDropdown(getTextureOptions), "SOUTH");
                this.appendDummyInput("sixSidedTextures")
                    .appendField("Osten")
                    .appendField(new Blockly.FieldDropdown(getTextureOptions), "EAST");
                this.appendDummyInput("sixSidedTextures")
                    .appendField("Westen")
                    .appendField(new Blockly.FieldDropdown(getTextureOptions), "WEST");
                this.appendDummyInput()
                    .appendField("Härte")
                    .appendField(new Blockly.FieldNumber(5, 0, 100, 1), "RESISTANCE");
                this.appendDummyInput()
                    .appendField("Lichtdurchlässigkeit")
                    .appendField(new Blockly.FieldNumber(0, 0, 32, 1), "LIGHT_ABSORPTION");
                this.appendDummyInput()
                    .appendField("Kollision")
                    .appendField(new Blockly.FieldDropdown([["Voll", "FULL"], ["Keine", "NONE"]]), "COLLISION_TYPE");
                this.appendDummyInput()
                    .appendField("Durchgang")
                    .appendField(new Blockly.FieldCheckbox("FALSE"), "WALKABLE");
                this.appendDummyInput()
                    .appendField("Drop")
                    .appendField(new Blockly.FieldDropdown(getDropOptions), "DROP");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour(120);
                this.setOnChange(function(changeEvent) {
                    const textureType = this.getFieldValue('TEXTURE_TYPE');
                    const singleInput = this.getInput('singleTexture');
                    singleInput.setVisible(textureType === 'SINGLE');
                    for (let i = 0; i < this.inputList.length; i++) {
                        const input = this.inputList[i];
                        if (input.name === 'sixSidedTextures') {
                            input.setVisible(textureType === 'SIX_SIDED');
                        }
                    }
                    this.render();
                });
            }
        };

        Blockly.JavaScript['vs_new_block'] = function(block) {
            var name = block.getFieldValue('NAME');
            var textureType = block.getFieldValue('TEXTURE_TYPE');
            var resistance = block.getFieldValue('RESISTANCE');
            var lightAbsorption = block.getFieldValue('LIGHT_ABSORPTION');
            var collisionType = block.getFieldValue('COLLISION_TYPE');
            var walkable = block.getFieldValue('WALKABLE') === 'TRUE';
            var drop = block.getFieldValue('DROP');
            var json = {
                "code": `${modConfig.modName}:${name}`,
                "class": `${modConfig.modName}.Block${name}`,
                "drawtype": "Cube",
                "resistance": parseFloat(resistance),
                "lightAbsorption": parseInt(lightAbsorption),
                "walkable": walkable,
                "creativeinventory": { "general": ["*"] },
                "behaviors": []
            };
            if (collisionType === 'FULL') {
                json.collisionSelectionBoxes = [{ "x1": 0, "y1": 0, "z1": 0, "x2": 1, "y2": 1, "z2": 1 }];
            } else {
                json.collisionSelectionBoxes = [];
            }
            json.drops = [{
                "type": "block",
                "code": drop === "SELF" ? `${modConfig.modName}:${name}` : drop,
                "quantity": { "avg": 1, "var": 0 }
            }];
            if (textureType === 'SINGLE') {
                var texture = block.getFieldValue('TEXTURE') !== "none" ? `block/${path.basename(block.getFieldValue('TEXTURE'), '.png')}` : "game:blocks/stone";
                json.texture = { "base": texture };
            } else {
                var top = block.getFieldValue('TOP') !== "none" ? `block/${path.basename(block.getFieldValue('TOP'), '.png')}` : "game:blocks/stone";
                var bottom = block.getFieldValue('BOTTOM') !== "none" ? `block/${path.basename(block.getFieldValue('BOTTOM'), '.png')}` : "game:blocks/stone";
                var north = block.getFieldValue('NORTH') !== "none" ? `block/${path.basename(block.getFieldValue('NORTH'), '.png')}` : "game:blocks/stone";
                var south = block.getFieldValue('SOUTH') !== "none" ? `block/${path.basename(block.getFieldValue('SOUTH'), '.png')}` : "game:blocks/stone";
                var east = block.getFieldValue('EAST') !== "none" ? `block/${path.basename(block.getFieldValue('EAST'), '.png')}` : "game:blocks/stone";
                var west = block.getFieldValue('WEST') !== "none" ? `block/${path.basename(block.getFieldValue('WEST'), '.png')}` : "game:blocks/stone";
                json.textures = {
                    "up": { "base": top },
                    "down": { "base": bottom },
                    "north": { "base": north },
                    "south": { "base": south },
                    "east": { "base": east },
                    "west": { "base": west }
                };
            }
            var csharp = `
using Vintagestory.API.Common;

namespace ${modConfig.modName} {
    public class Block${name} : Block {
        public override void OnLoaded(ICoreAPI api) {
            base.OnLoaded(api);
            api.Logger.Notification("Block${name} loaded successfully!");
        }
    }
}
`;
            return JSON.stringify(json, null, 2) + '|||csharp:' + name + ':' + csharp + '|||';
        };

        function getTextureOptions() {
            if (textureList.length === 0) {
                return [["Keine Texturen geladen", "none"]];
            }
            return textureList.map((texture, index) => [`Textur ${index + 1}: ${path.basename(texture)}`, texture]);
        }

        function getDropOptions() {
            return [
                ["Sich selbst", "SELF"],
                ["Stein", "game:stone"],
                ["Holz", "game:plank-oak"]
            ];
        }

        Blockly.Blocks['vs_new_recipe'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Neues Rezept")
                    .appendField(new Blockly.FieldTextInput("S_,H_", validatePattern), "PATTERN");
                this.appendDummyInput()
                    .appendField("Zutat 1")
                    .appendField(new Blockly.FieldTextInput("game:stick", validateCode), "ING1");
                this.appendDummyInput()
                    .appendField("Zutat 2")
                    .appendField(new Blockly.FieldTextInput("game:plank-oak", validateCode), "ING2");
                this.appendDummyInput()
                    .appendField("Ergebnis")
                    .appendField(new Blockly.FieldTextInput(`${modConfig.modName}:table`, validateCode), "OUTPUT");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour(230);
            }
        };

        Blockly.JavaScript['vs_new_recipe'] = function(block) {
            var pattern = block.getFieldValue('PATTERN');
            var ing1 = block.getFieldValue('ING1');
            var ing2 = block.getFieldValue('ING2');
            var output = block.getFieldValue('OUTPUT');
            var json = {
                "ingredientPattern": pattern,
                "ingredients": {
                    "S": { "type": "item", "code": ing1 },
                    "H": { "type": "item", "code": ing2 }
                },
                "output": { "type": "item", "code": output }
            };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_multiblock'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Multiblock")
                    .appendField(new Blockly.FieldTextInput("mymultiblock", validateName), "NAME");
                this.appendDummyInput()
                    .appendField("Muster")
                    .appendField(new Blockly.FieldTextInput("BBB,B_B", validatePattern), "PATTERN");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour(160);
            }
        };

        Blockly.JavaScript['vs_multiblock'] = function(block) {
            var name = block.getFieldValue('NAME');
            var pattern = block.getFieldValue('PATTERN').split(',');
            var json = {
                "code": `${modConfig.modName}:${name}`,
                "class": "Block",
                "shape": { "base": "game:shapes/multiblock", "pattern": pattern },
                "blockelements": [{ "code": "game:stone" }]
            };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_block_behavior'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Verhalten für")
                    .appendField(new Blockly.FieldDropdown(this.getBlockOptions.bind(this), this.validateBlockName), "BLOCKNAME");
                this.appendDummyInput()
                    .appendField("Aktion")
                    .appendField(new Blockly.FieldTextInput("Nachricht anzeigen", validateText), "ACTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour(200);
            },
            getBlockOptions: function() {
                const blocks = workspace.getAllBlocks().filter(b => b.type === 'vs_new_block');
                const options = blocks.map(b => {
                    const name = b.getFieldValue('NAME');
                    return [name, name];
                });
                if (options.length === 0) {
                    return [["Kein Block definiert", "myblock"]];
                }
                return options;
            },
            validateBlockName: function(newValue) {
                return newValue || "myblock";
            }
        };

        Blockly.JavaScript['vs_block_behavior'] = function(block) {
            var blockName = block.getFieldValue('BLOCKNAME');
            var action = block.getFieldValue('ACTION');
            var behaviorJson = {
                "name": `${modConfig.modName}.Behavior${blockName}`
            };
            var csharp = `
using Vintagestory.API.Common;
using Vintagestory.API.Server;
using Vintagestory.API.Client;

namespace ${modConfig.modName} {
    public class Behavior${blockName} : BlockBehavior {
        public Behavior${blockName}(Block block) : base(block) {
        }

        public override bool OnBlockInteractStart(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling) {
            if (world.Side == EnumAppSide.Client) {
                ICoreClientAPI capi = world.Api as ICoreClientAPI;
                capi.ShowChatMessage("Client: Interaktion mit ${blockName}!");
            }
            if (world.Side == EnumAppSide.Server) {
                ICoreServerAPI sapi = world.Api as ICoreServerAPI;
                sapi.SendMessage(byPlayer, 0, "${action}", EnumChatType.Notification);
                world.Logger.Notification("Behavior${blockName} triggered for block " + block.Code);
            }
            handling = EnumHandling.PreventDefault;
            return true;
        }
    }
}
`;
            return `json:${JSON.stringify(behaviorJson, null, 2)}|||csharp:Behavior${blockName}:${csharp}|||`;
        };

        Blockly.Blocks['vs_block_gui_csharp'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("GUI für Block")
                    .appendField(new Blockly.FieldDropdown(this.getBlockOptions.bind(this), this.validateBlockName), "BLOCKNAME");
                this.appendDummyInput()
                    .appendField("Button Text")
                    .appendField(new Blockly.FieldTextInput("Klick mich", validateText), "BUTTON");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour(250);
            },
            getBlockOptions: function() {
                const blocks = workspace.getAllBlocks().filter(b => b.type === 'vs_new_block');
                const options = blocks.map(b => {
                    const name = b.getFieldValue('NAME');
                    return [name, name];
                });
                if (options.length === 0) {
                    return [["Kein Block definiert", "myblock"]];
                }
                return options;
            },
            validateBlockName: function(newValue) {
                return newValue || "myblock";
            }
        };

        Blockly.JavaScript['vs_block_gui_csharp'] = function(block) {
            var blockName = block.getFieldValue('BLOCKNAME');
            var buttonText = block.getFieldValue('BUTTON');
            var csharp = `
using Vintagestory.API.Common;
using Vintagestory.API.Client;

namespace ${modConfig.modName} {
    public class Block${blockName} : Block {
        public override bool OnBlockInteractStart(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel) {
            if (world.Side == EnumAppSide.Client) {
                ICoreClientAPI capi = (world.Api as ICoreClientAPI);
                GuiDialog dlg = new GuiDialog${blockName}(capi);
                dlg.TryOpen();
            }
            return true;
        }
    }

    public class GuiDialog${blockName} : GuiDialog {
        public override string ToggleKeyCombinationCode => "mygui_${blockName}";
        public GuiDialog${blockName}(ICoreClientAPI capi) : base(capi) { SetupDialog(); }
        private void SetupDialog() {
            ElementBounds dialogBounds = ElementBounds.Fixed(0, 0, 200, 100);
            SingleComposer = capi.Gui.CreateCompo("mygui_${blockName}", dialogBounds)
                .AddButton("${buttonText}", OnButtonPressed, ElementBounds.Fixed(10, 30, 180, 40))
                .Compose();
        }
        private bool OnButtonPressed() {
            capi.ShowChatMessage("Button geklickt!");
            TryClose();
            return true;
        }
    }
}
`;
            return 'csharp:' + blockName + ':' + csharp + '|||';
        };

        Blockly.Blocks['vs_event_handler'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Wenn Block platziert")
                    .appendField(new Blockly.FieldTextInput("myblock", validateName), "BLOCKNAME");
                this.appendDummyInput()
                    .appendField("Aktion")
                    .appendField(new Blockly.FieldTextInput("Explodiere", validateText), "ACTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour(180);
            }
        };

        Blockly.JavaScript['vs_event_handler'] = function(block) {
            var blockName = block.getFieldValue('BLOCKNAME');
            var action = block.getFieldValue('ACTION');
            var csharp = `
using Vintagestory.API.Common;

namespace ${modConfig.modName} {
    public class Event${blockName} : ModSystem {
        public override void Start(ICoreAPI api) {
            base.Start(api);
            api.Event.BlockPlaced += (world, byPlayer, blockSel) => {
                if (blockSel.Block.Code == "${modConfig.modName}:${blockName}") {
                    world.Logger.Notification("${action}");
                }
            };
        }
    }
}
`;
            return 'csharp:' + blockName + ':' + csharp + '|||';
        };

        // ========== ITEMS & WERKZEUGE ==========
        Blockly.Blocks['vs_new_item'] = {
            init: function() {
                this.appendDummyInput().appendField("Neues Item").appendField(new Blockly.FieldTextInput("myitem", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Stapelgröße").appendField(new Blockly.FieldNumber(64, 1, 999), "STACK_SIZE");
                this.appendDummyInput().appendField("Kategorie").appendField(new Blockly.FieldDropdown([["Allgemein","general"],["Werkzeuge","tools"],["Materialien","materials"],["Nahrung","food"]]), "CATEGORY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_new_item'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE'), stackSize = block.getFieldValue('STACK_SIZE'), category = block.getFieldValue('CATEGORY');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "Item", "maxstacksize": parseInt(stackSize), "creativeinventory": { [category]: ["*"] }, "texture": { "base": texture !== "none" ? `item/${path.basename(texture, '.png')}` : "game:item/unknown" } };
            return JSON.stringify(json, null, 2) + '|||item|||';
        };

        Blockly.Blocks['vs_new_tool'] = {
            init: function() {
                this.appendDummyInput().appendField("Neues Werkzeug").appendField(new Blockly.FieldTextInput("mytool", validateName), "NAME");
                this.appendDummyInput().appendField("Typ").appendField(new Blockly.FieldDropdown([["Spitzhacke","Pickaxe"],["Axt","Axe"],["Schaufel","Shovel"],["Schwert","Sword"],["Messer","Knife"],["Hacke","Hoe"],["Hammer","Hammer"],["Säge","Saw"]]), "TOOL_TYPE");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Haltbarkeit").appendField(new Blockly.FieldNumber(250, 1, 10000), "DURABILITY");
                this.appendDummyInput().appendField("Abbaugeschwindigkeit").appendField(new Blockly.FieldNumber(4.0, 0.1, 20, 0.1), "MINING_SPEED");
                this.appendDummyInput().appendField("Angriffskraft").appendField(new Blockly.FieldNumber(3.0, 0.5, 50, 0.5), "ATTACK_POWER");
                this.appendDummyInput().appendField("Stufe").appendField(new Blockly.FieldDropdown([["Stein","1"],["Kupfer","2"],["Bronze","3"],["Eisen","4"],["Stahl","5"],["Titan","6"]]), "TIER");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_new_tool'] = function(block) {
            var name = block.getFieldValue('NAME'), toolType = block.getFieldValue('TOOL_TYPE'), texture = block.getFieldValue('TEXTURE');
            var durability = block.getFieldValue('DURABILITY'), miningSpeed = block.getFieldValue('MINING_SPEED'), attackPower = block.getFieldValue('ATTACK_POWER'), tier = block.getFieldValue('TIER');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "ItemTool", "tool": toolType.toLowerCase(), "durability": parseInt(durability), "miningSpeed": { "*": parseFloat(miningSpeed) }, "attackPower": parseFloat(attackPower), "toolTier": parseInt(tier), "creativeinventory": { "tools": ["*"] }, "texture": { "base": texture !== "none" ? `item/${path.basename(texture, '.png')}` : "game:item/unknown" } };
            return JSON.stringify(json, null, 2) + '|||item|||';
        };

        Blockly.Blocks['vs_new_weapon'] = {
            init: function() {
                this.appendDummyInput().appendField("Neue Waffe").appendField(new Blockly.FieldTextInput("myweapon", validateName), "NAME");
                this.appendDummyInput().appendField("Typ").appendField(new Blockly.FieldDropdown([["Schwert","Sword"],["Speer","Spear"],["Axt","Axe"],["Messer","Knife"],["Keule","Club"],["Bogen","Bow"]]), "WEAPON_TYPE");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Schaden").appendField(new Blockly.FieldNumber(5.0, 0.5, 100, 0.5), "DAMAGE");
                this.appendDummyInput().appendField("Reichweite").appendField(new Blockly.FieldNumber(1.5, 0.5, 10, 0.1), "REACH");
                this.appendDummyInput().appendField("Haltbarkeit").appendField(new Blockly.FieldNumber(300, 1, 10000), "DURABILITY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_new_weapon'] = function(block) {
            var name = block.getFieldValue('NAME'), weaponType = block.getFieldValue('WEAPON_TYPE'), texture = block.getFieldValue('TEXTURE');
            var damage = block.getFieldValue('DAMAGE'), reach = block.getFieldValue('REACH'), durability = block.getFieldValue('DURABILITY');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "ItemSword", "tool": weaponType.toLowerCase(), "durability": parseInt(durability), "attackPower": parseFloat(damage), "attackRange": parseFloat(reach), "creativeinventory": { "tools": ["*"] }, "texture": { "base": texture !== "none" ? `item/${path.basename(texture, '.png')}` : "game:item/unknown" } };
            return JSON.stringify(json, null, 2) + '|||item|||';
        };

        Blockly.Blocks['vs_new_armor'] = {
            init: function() {
                this.appendDummyInput().appendField("Neue Rüstung").appendField(new Blockly.FieldTextInput("myarmor", validateName), "NAME");
                this.appendDummyInput().appendField("Slot").appendField(new Blockly.FieldDropdown([["Kopf","head"],["Körper","body"],["Beine","legs"],["Füße","feet"]]), "SLOT");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Schutz (%)").appendField(new Blockly.FieldNumber(15, 1, 100), "PROTECTION");
                this.appendDummyInput().appendField("Haltbarkeit").appendField(new Blockly.FieldNumber(500, 1, 10000), "DURABILITY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_new_armor'] = function(block) {
            var name = block.getFieldValue('NAME'), slot = block.getFieldValue('SLOT'), texture = block.getFieldValue('TEXTURE');
            var protection = block.getFieldValue('PROTECTION'), durability = block.getFieldValue('DURABILITY');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "ItemWearable", "clothingType": slot, "durability": parseInt(durability), "protectionModifiers": { "flatDamageReduction": parseFloat(protection) / 100, "relativeProtection": parseFloat(protection) / 100 }, "creativeinventory": { "general": ["*"] }, "texture": { "base": texture !== "none" ? `item/${path.basename(texture, '.png')}` : "game:item/unknown" } };
            return JSON.stringify(json, null, 2) + '|||item|||';
        };

        Blockly.Blocks['vs_item_durability'] = {
            init: function() {
                this.appendDummyInput().appendField("Haltbarkeit für").appendField(new Blockly.FieldDropdown(this.getItemOptions.bind(this)), "ITEM");
                this.appendDummyInput().appendField("Wert").appendField(new Blockly.FieldNumber(100, 1, 99999), "VALUE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            },
            getItemOptions: function() { return [["Kein Item definiert", "none"]]; }
        };
        Blockly.JavaScript['vs_item_durability'] = function(block) { return ''; };

        Blockly.Blocks['vs_tool_mining_speed'] = {
            init: function() {
                this.appendDummyInput().appendField("Abbaugeschwindigkeit");
                this.appendDummyInput().appendField("Material").appendField(new Blockly.FieldDropdown([["Stein","stone"],["Holz","wood"],["Erz","ore"],["Erde","soil"],["Alle","*"]]), "MATERIAL");
                this.appendDummyInput().appendField("Geschwindigkeit").appendField(new Blockly.FieldNumber(4.0, 0.1, 50, 0.1), "SPEED");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_tool_mining_speed'] = function(block) { return ''; };

        Blockly.Blocks['vs_tool_tier'] = {
            init: function() {
                this.appendDummyInput().appendField("Werkzeugstufe definieren").appendField(new Blockly.FieldTextInput("mytier", validateName), "NAME");
                this.appendDummyInput().appendField("Stufe").appendField(new Blockly.FieldNumber(1, 0, 10), "LEVEL");
                this.appendDummyInput().appendField("Abbaubar").appendField(new Blockly.FieldTextInput("stone,ore", validatePattern), "MINEABLE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_tool_tier'] = function(block) { return ''; };

        Blockly.Blocks['vs_item_stack_size'] = {
            init: function() {
                this.appendDummyInput().appendField("Stapelgröße ändern");
                this.appendDummyInput().appendField("Item").appendField(new Blockly.FieldTextInput("game:stick", validateCode), "ITEM");
                this.appendDummyInput().appendField("Größe").appendField(new Blockly.FieldNumber(64, 1, 9999), "SIZE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_item_stack_size'] = function(block) { return ''; };

        Blockly.Blocks['vs_item_attributes'] = {
            init: function() {
                this.appendDummyInput().appendField("Item Attribute").appendField(new Blockly.FieldTextInput("myitem", validateName), "ITEM");
                this.appendDummyInput().appendField("Attribut").appendField(new Blockly.FieldTextInput("customValue", validateName), "ATTR_NAME");
                this.appendDummyInput().appendField("Wert").appendField(new Blockly.FieldTextInput("100", validateText), "ATTR_VALUE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_item_attributes'] = function(block) { return ''; };

        Blockly.Blocks['vs_throwable_item'] = {
            init: function() {
                this.appendDummyInput().appendField("Werfbares Item").appendField(new Blockly.FieldTextInput("mythrowable", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Schaden").appendField(new Blockly.FieldNumber(3.0, 0, 50, 0.5), "DAMAGE");
                this.appendDummyInput().appendField("Wurfweite").appendField(new Blockly.FieldNumber(20, 1, 100), "RANGE");
                this.appendDummyInput().appendField("Stapelgröße").appendField(new Blockly.FieldNumber(16, 1, 64), "STACK");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(285);
            }
        };
        Blockly.JavaScript['vs_throwable_item'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE'), damage = block.getFieldValue('DAMAGE'), range = block.getFieldValue('RANGE'), stack = block.getFieldValue('STACK');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "ItemStone", "maxstacksize": parseInt(stack), "attackPower": parseFloat(damage), "attributes": { "throwRange": parseInt(range) }, "creativeinventory": { "general": ["*"] }, "texture": { "base": texture !== "none" ? `item/${path.basename(texture, '.png')}` : "game:item/unknown" } };
            return JSON.stringify(json, null, 2) + '|||item|||';
        };

        // ========== ENTITIES & KREATUREN ==========
        Blockly.Blocks['vs_new_entity'] = {
            init: function() {
                this.appendDummyInput().appendField("Neue Kreatur").appendField(new Blockly.FieldTextInput("mycreature", validateName), "NAME");
                this.appendDummyInput().appendField("Typ").appendField(new Blockly.FieldDropdown([["Tier","Creature"],["Monster","Monster"],["NPC","Humanoid"],["Passiv","PassiveCreature"]]), "TYPE");
                this.appendDummyInput().appendField("HP").appendField(new Blockly.FieldNumber(20, 1, 1000), "HEALTH");
                this.appendDummyInput().appendField("Geschwindigkeit").appendField(new Blockly.FieldNumber(0.03, 0.001, 1, 0.001), "SPEED");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_new_entity'] = function(block) {
            var name = block.getFieldValue('NAME'), type = block.getFieldValue('TYPE'), health = block.getFieldValue('HEALTH'), speed = block.getFieldValue('SPEED');
            var json = { "code": `${modConfig.modName}:${name}`, "class": type, "hitboxSize": { "x": 0.5, "y": 1 }, "deadHitboxSize": { "x": 0.5, "y": 0.25 }, "eyeHeight": 0.9, "attributes": { "health": parseInt(health), "walkSpeed": parseFloat(speed) }, "client": { "renderer": "Shape", "shape": { "base": `entity/${name}` } }, "server": { "behaviors": [{ "code": "health", "attributes": { "maxhealth": parseInt(health) } }] } };
            return JSON.stringify(json, null, 2) + '|||entity|||';
        };

        Blockly.Blocks['vs_entity_ai'] = {
            init: function() {
                this.appendDummyInput().appendField("KI für Kreatur").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("Verhalten").appendField(new Blockly.FieldDropdown([["Passiv","idle"],["Aggressiv","meleeattack"],["Fliehen","fleeondamage"],["Wandern","wander"],["Folgen","followentity"],["Schwimmen","float"]]), "BEHAVIOR");
                this.appendDummyInput().appendField("Priorität").appendField(new Blockly.FieldNumber(1, 0, 10), "PRIORITY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_ai'] = function(block) { return ''; };

        Blockly.Blocks['vs_entity_stats'] = {
            init: function() {
                this.appendDummyInput().appendField("Statistiken für").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("HP").appendField(new Blockly.FieldNumber(20, 1, 1000), "HEALTH");
                this.appendDummyInput().appendField("Schaden").appendField(new Blockly.FieldNumber(3, 0, 100), "DAMAGE");
                this.appendDummyInput().appendField("Rüstung").appendField(new Blockly.FieldNumber(0, 0, 100), "ARMOR");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_stats'] = function(block) { return ''; };

        Blockly.Blocks['vs_entity_drops'] = {
            init: function() {
                this.appendDummyInput().appendField("Drops für").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("Item").appendField(new Blockly.FieldTextInput("game:meat-raw", validateCode), "DROP_ITEM");
                this.appendDummyInput().appendField("Menge (min)").appendField(new Blockly.FieldNumber(1, 0, 64), "MIN");
                this.appendDummyInput().appendField("Menge (max)").appendField(new Blockly.FieldNumber(3, 0, 64), "MAX");
                this.appendDummyInput().appendField("Chance (%)").appendField(new Blockly.FieldNumber(100, 0, 100), "CHANCE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_drops'] = function(block) { return ''; };

        Blockly.Blocks['vs_entity_spawn'] = {
            init: function() {
                this.appendDummyInput().appendField("Spawn für").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("Biom").appendField(new Blockly.FieldDropdown([["Überall","*"],["Wald","forest"],["Ebene","plain"],["Wüste","desert"],["Schnee","arctic"],["Sumpf","swamp"]]), "BIOME");
                this.appendDummyInput().appendField("Gruppengröße").appendField(new Blockly.FieldNumber(3, 1, 20), "GROUP_SIZE");
                this.appendDummyInput().appendField("Gewichtung").appendField(new Blockly.FieldNumber(1, 0.1, 10, 0.1), "WEIGHT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_spawn'] = function(block) { return ''; };

        Blockly.Blocks['vs_entity_animation'] = {
            init: function() {
                this.appendDummyInput().appendField("Animation für").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("Animation").appendField(new Blockly.FieldDropdown([["Idle","idle"],["Laufen","walk"],["Rennen","run"],["Angriff","attack"],["Tod","die"],["Schwimmen","swim"]]), "ANIM_TYPE");
                this.appendDummyInput().appendField("Datei").appendField(new Blockly.FieldTextInput("walk", validateName), "ANIM_FILE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_animation'] = function(block) { return ''; };

        Blockly.Blocks['vs_entity_sounds'] = {
            init: function() {
                this.appendDummyInput().appendField("Sound für").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("Ereignis").appendField(new Blockly.FieldDropdown([["Idle","idle"],["Verletzt","hurt"],["Tod","death"],["Angriff","attack"]]), "EVENT");
                this.appendDummyInput().appendField("Sound").appendField(new Blockly.FieldTextInput("game:creature/wolf-idle", validateCode), "SOUND");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_sounds'] = function(block) { return ''; };

        Blockly.Blocks['vs_entity_taming'] = {
            init: function() {
                this.appendDummyInput().appendField("Zähmbar").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("Futter").appendField(new Blockly.FieldTextInput("game:grain-wheat", validateCode), "FOOD");
                this.appendDummyInput().appendField("Zähmzeit (Tage)").appendField(new Blockly.FieldNumber(3, 1, 30), "DAYS");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_taming'] = function(block) { return ''; };

        Blockly.Blocks['vs_entity_breeding'] = {
            init: function() {
                this.appendDummyInput().appendField("Zucht für").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("Nachwuchs").appendField(new Blockly.FieldTextInput("mycreature-baby", validateName), "OFFSPRING");
                this.appendDummyInput().appendField("Tragezeit (Tage)").appendField(new Blockly.FieldNumber(5, 1, 60), "GESTATION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_breeding'] = function(block) { return ''; };

        Blockly.Blocks['vs_entity_mount'] = {
            init: function() {
                this.appendDummyInput().appendField("Reitbar").appendField(new Blockly.FieldTextInput("mycreature", validateName), "ENTITY");
                this.appendDummyInput().appendField("Geschwindigkeit").appendField(new Blockly.FieldNumber(0.1, 0.01, 1, 0.01), "SPEED");
                this.appendDummyInput().appendField("Sprunghöhe").appendField(new Blockly.FieldNumber(1.5, 0.5, 5, 0.5), "JUMP");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_entity_mount'] = function(block) { return ''; };

        Blockly.Blocks['vs_npc_trader'] = {
            init: function() {
                this.appendDummyInput().appendField("NPC Händler").appendField(new Blockly.FieldTextInput("mytrader", validateName), "NAME");
                this.appendDummyInput().appendField("Verkauft").appendField(new Blockly.FieldTextInput("game:sword-iron", validateCode), "SELLS");
                this.appendDummyInput().appendField("Preis").appendField(new Blockly.FieldNumber(10, 1, 9999), "PRICE");
                this.appendDummyInput().appendField("Währung").appendField(new Blockly.FieldTextInput("game:gear-rusty", validateCode), "CURRENCY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_npc_trader'] = function(block) { return ''; };

        Blockly.Blocks['vs_boss_entity'] = {
            init: function() {
                this.appendDummyInput().appendField("Boss Kreatur").appendField(new Blockly.FieldTextInput("myboss", validateName), "NAME");
                this.appendDummyInput().appendField("HP").appendField(new Blockly.FieldNumber(500, 1, 99999), "HEALTH");
                this.appendDummyInput().appendField("Phasen").appendField(new Blockly.FieldNumber(3, 1, 10), "PHASES");
                this.appendDummyInput().appendField("Schaden").appendField(new Blockly.FieldNumber(15, 1, 999), "DAMAGE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(0);
            }
        };
        Blockly.JavaScript['vs_boss_entity'] = function(block) { return ''; };

        // ========== WELTGENERIERUNG ==========
        Blockly.Blocks['vs_ore_deposit'] = {
            init: function() {
                this.appendDummyInput().appendField("Erzvorkommen").appendField(new Blockly.FieldTextInput("myore", validateName), "NAME");
                this.appendDummyInput().appendField("Block").appendField(new Blockly.FieldTextInput("game:ore-iron", validateCode), "BLOCK");
                this.appendDummyInput().appendField("Min. Höhe").appendField(new Blockly.FieldNumber(1, 0, 256), "MIN_Y");
                this.appendDummyInput().appendField("Max. Höhe").appendField(new Blockly.FieldNumber(64, 0, 256), "MAX_Y");
                this.appendDummyInput().appendField("Häufigkeit").appendField(new Blockly.FieldNumber(5, 1, 100), "FREQUENCY");
                this.appendDummyInput().appendField("Größe").appendField(new Blockly.FieldNumber(8, 1, 64), "SIZE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160);
            }
        };
        Blockly.JavaScript['vs_ore_deposit'] = function(block) {
            var json = { "code": `${modConfig.modName}:${block.getFieldValue('NAME')}`, "variant": { "type": "deposit" }, "deposits": [{ "block": block.getFieldValue('BLOCK'), "minY": parseInt(block.getFieldValue('MIN_Y')), "maxY": parseInt(block.getFieldValue('MAX_Y')), "frequency": parseInt(block.getFieldValue('FREQUENCY')), "quantity": parseInt(block.getFieldValue('SIZE')) }] };
            return JSON.stringify(json, null, 2) + '|||worldgen|||';
        };

        Blockly.Blocks['vs_structure_gen'] = {
            init: function() {
                this.appendDummyInput().appendField("Struktur").appendField(new Blockly.FieldTextInput("mystructure", validateName), "NAME");
                this.appendDummyInput().appendField("Häufigkeit").appendField(new Blockly.FieldNumber(1, 0.1, 100, 0.1), "FREQUENCY");
                this.appendDummyInput().appendField("Biom").appendField(new Blockly.FieldDropdown([["Überall","*"],["Wald","forest"],["Ebene","plain"],["Wüste","desert"]]), "BIOME");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160);
            }
        };
        Blockly.JavaScript['vs_structure_gen'] = function(block) { return ''; };

        Blockly.Blocks['vs_biome_modifier'] = {
            init: function() {
                this.appendDummyInput().appendField("Biom Modifikator");
                this.appendDummyInput().appendField("Biom").appendField(new Blockly.FieldDropdown([["Wald","forest"],["Ebene","plain"],["Wüste","desert"],["Schnee","arctic"],["Sumpf","swamp"]]), "BIOME");
                this.appendDummyInput().appendField("Temperatur").appendField(new Blockly.FieldNumber(15, -50, 50), "TEMP");
                this.appendDummyInput().appendField("Feuchtigkeit").appendField(new Blockly.FieldNumber(50, 0, 100), "HUMIDITY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160);
            }
        };
        Blockly.JavaScript['vs_biome_modifier'] = function(block) { return ''; };

        Blockly.Blocks['vs_tree_type'] = {
            init: function() {
                this.appendDummyInput().appendField("Baumtyp").appendField(new Blockly.FieldTextInput("mytree", validateName), "NAME");
                this.appendDummyInput().appendField("Holzblock").appendField(new Blockly.FieldTextInput("game:log-oak", validateCode), "LOG");
                this.appendDummyInput().appendField("Blätterblock").appendField(new Blockly.FieldTextInput("game:leaves-oak", validateCode), "LEAVES");
                this.appendDummyInput().appendField("Max. Höhe").appendField(new Blockly.FieldNumber(12, 3, 50), "HEIGHT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160);
            }
        };
        Blockly.JavaScript['vs_tree_type'] = function(block) { return ''; };

        Blockly.Blocks['vs_cave_decorator'] = {
            init: function() {
                this.appendDummyInput().appendField("Höhlen-Dekoration").appendField(new Blockly.FieldTextInput("mycavedeco", validateName), "NAME");
                this.appendDummyInput().appendField("Block").appendField(new Blockly.FieldTextInput("game:stalactite", validateCode), "BLOCK");
                this.appendDummyInput().appendField("Häufigkeit (%)").appendField(new Blockly.FieldNumber(5, 1, 100), "FREQUENCY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160);
            }
        };
        Blockly.JavaScript['vs_cave_decorator'] = function(block) { return ''; };

        Blockly.Blocks['vs_surface_deposit'] = {
            init: function() {
                this.appendDummyInput().appendField("Oberflächenressource").appendField(new Blockly.FieldTextInput("mysurfaceore", validateName), "NAME");
                this.appendDummyInput().appendField("Block").appendField(new Blockly.FieldTextInput("game:loosestones-flint", validateCode), "BLOCK");
                this.appendDummyInput().appendField("Häufigkeit").appendField(new Blockly.FieldNumber(3, 0.1, 100, 0.1), "FREQUENCY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160);
            }
        };
        Blockly.JavaScript['vs_surface_deposit'] = function(block) { return ''; };

        Blockly.Blocks['vs_ruins_generator'] = {
            init: function() {
                this.appendDummyInput().appendField("Ruinen Generator").appendField(new Blockly.FieldTextInput("myruins", validateName), "NAME");
                this.appendDummyInput().appendField("Größe").appendField(new Blockly.FieldDropdown([["Klein","small"],["Mittel","medium"],["Groß","large"]]), "SIZE");
                this.appendDummyInput().appendField("Häufigkeit").appendField(new Blockly.FieldNumber(0.5, 0.1, 10, 0.1), "FREQUENCY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160);
            }
        };
        Blockly.JavaScript['vs_ruins_generator'] = function(block) { return ''; };

        Blockly.Blocks['vs_dungeon_gen'] = {
            init: function() {
                this.appendDummyInput().appendField("Dungeon Generator").appendField(new Blockly.FieldTextInput("mydungeon", validateName), "NAME");
                this.appendDummyInput().appendField("Tiefe").appendField(new Blockly.FieldNumber(20, 1, 100), "DEPTH");
                this.appendDummyInput().appendField("Räume").appendField(new Blockly.FieldNumber(5, 1, 50), "ROOMS");
                this.appendDummyInput().appendField("Loot-Tabelle").appendField(new Blockly.FieldTextInput("dungeon-loot", validateName), "LOOT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(160);
            }
        };
        Blockly.JavaScript['vs_dungeon_gen'] = function(block) { return ''; };

        // ========== CRAFTING & VERARBEITUNG ==========
        Blockly.Blocks['vs_grid_recipe'] = {
            init: function() {
                this.appendDummyInput().appendField("Grid Rezept").appendField(new Blockly.FieldTextInput("myrecipe", validateName), "NAME");
                this.appendDummyInput().appendField("Muster (3x3)").appendField(new Blockly.FieldTextInput("AAA,ABA,AAA", validatePattern), "PATTERN");
                this.appendDummyInput().appendField("A =").appendField(new Blockly.FieldTextInput("game:plank-oak", validateCode), "ING_A");
                this.appendDummyInput().appendField("B =").appendField(new Blockly.FieldTextInput("game:stick", validateCode), "ING_B");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:chest", validateCode), "OUTPUT");
                this.appendDummyInput().appendField("Menge").appendField(new Blockly.FieldNumber(1, 1, 64), "QUANTITY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_grid_recipe'] = function(block) {
            var pattern = block.getFieldValue('PATTERN'), ingA = block.getFieldValue('ING_A'), ingB = block.getFieldValue('ING_B'), output = block.getFieldValue('OUTPUT'), qty = block.getFieldValue('QUANTITY');
            var json = { "ingredientPattern": pattern, "ingredients": { "A": { "type": "item", "code": ingA }, "B": { "type": "item", "code": ingB } }, "output": { "type": "item", "code": output, "quantity": parseInt(qty) } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_barrel_recipe'] = {
            init: function() {
                this.appendDummyInput().appendField("Fass-Rezept").appendField(new Blockly.FieldTextInput("mybarrel", validateName), "NAME");
                this.appendDummyInput().appendField("Eingabe").appendField(new Blockly.FieldTextInput("game:fruit-apple", validateCode), "INPUT");
                this.appendDummyInput().appendField("Flüssigkeit").appendField(new Blockly.FieldTextInput("game:water", validateCode), "LIQUID");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:cider", validateCode), "OUTPUT");
                this.appendDummyInput().appendField("Dauer (Stunden)").appendField(new Blockly.FieldNumber(24, 1, 720), "DURATION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_barrel_recipe'] = function(block) {
            var json = { "code": `${modConfig.modName}:barrel-${block.getFieldValue('NAME')}`, "input": block.getFieldValue('INPUT'), "liquid": block.getFieldValue('LIQUID'), "output": block.getFieldValue('OUTPUT'), "sealHours": parseInt(block.getFieldValue('DURATION')) };
            return JSON.stringify(json, null, 2) + '|||barrelrecipe|||';
        };

        Blockly.Blocks['vs_clay_forming'] = {
            init: function() {
                this.appendDummyInput().appendField("Tonformen").appendField(new Blockly.FieldTextInput("myclayform", validateName), "NAME");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:bowl-raw", validateCode), "OUTPUT");
                this.appendDummyInput().appendField("Ton benötigt").appendField(new Blockly.FieldNumber(2, 1, 16), "CLAY_AMOUNT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_clay_forming'] = function(block) {
            var json = { "code": `${modConfig.modName}:clayform-${block.getFieldValue('NAME')}`, "output": block.getFieldValue('OUTPUT'), "clayRequired": parseInt(block.getFieldValue('CLAY_AMOUNT')) };
            return JSON.stringify(json, null, 2) + '|||clayforming|||';
        };

        Blockly.Blocks['vs_smithing_recipe'] = {
            init: function() {
                this.appendDummyInput().appendField("Schmiedeamboss").appendField(new Blockly.FieldTextInput("mysmith", validateName), "NAME");
                this.appendDummyInput().appendField("Eingabe").appendField(new Blockly.FieldTextInput("game:ingot-iron", validateCode), "INPUT");
                this.appendDummyInput().appendField("Eingabe Menge").appendField(new Blockly.FieldNumber(1, 1, 10), "INPUT_QTY");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:pickaxehead-iron", validateCode), "OUTPUT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_smithing_recipe'] = function(block) {
            var json = { "code": `${modConfig.modName}:smithing-${block.getFieldValue('NAME')}`, "ingredient": { "type": "item", "code": block.getFieldValue('INPUT'), "quantity": parseInt(block.getFieldValue('INPUT_QTY')) }, "output": { "type": "item", "code": block.getFieldValue('OUTPUT') } };
            return JSON.stringify(json, null, 2) + '|||smithing|||';
        };

        Blockly.Blocks['vs_knapping_recipe'] = {
            init: function() {
                this.appendDummyInput().appendField("Steinbearbeitung").appendField(new Blockly.FieldTextInput("myknap", validateName), "NAME");
                this.appendDummyInput().appendField("Eingabe").appendField(new Blockly.FieldTextInput("game:stone-granite", validateCode), "INPUT");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:axehead-stone", validateCode), "OUTPUT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_knapping_recipe'] = function(block) {
            var json = { "code": `${modConfig.modName}:knapping-${block.getFieldValue('NAME')}`, "ingredient": block.getFieldValue('INPUT'), "output": block.getFieldValue('OUTPUT') };
            return JSON.stringify(json, null, 2) + '|||knapping|||';
        };

        Blockly.Blocks['vs_cooking_recipe'] = {
            init: function() {
                this.appendDummyInput().appendField("Kochrezept").appendField(new Blockly.FieldTextInput("mycooking", validateName), "NAME");
                this.appendDummyInput().appendField("Zutaten").appendField(new Blockly.FieldTextInput("game:meat-raw,game:vegetable-carrot", validateText), "INGREDIENTS");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:meal-hearty", validateCode), "OUTPUT");
                this.appendDummyInput().appendField("Kochzeit (Sek.)").appendField(new Blockly.FieldNumber(30, 1, 600), "TIME");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_cooking_recipe'] = function(block) { return ''; };

        Blockly.Blocks['vs_alloy_recipe'] = {
            init: function() {
                this.appendDummyInput().appendField("Legierung").appendField(new Blockly.FieldTextInput("myalloy", validateName), "NAME");
                this.appendDummyInput().appendField("Metall 1").appendField(new Blockly.FieldTextInput("game:ingot-copper", validateCode), "METAL1");
                this.appendDummyInput().appendField("Anteil 1 (%)").appendField(new Blockly.FieldNumber(90, 1, 99), "RATIO1");
                this.appendDummyInput().appendField("Metall 2").appendField(new Blockly.FieldTextInput("game:ingot-tin", validateCode), "METAL2");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:ingot-bronze", validateCode), "OUTPUT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_alloy_recipe'] = function(block) {
            var json = { "code": `${modConfig.modName}:alloy-${block.getFieldValue('NAME')}`, "ingredients": [{ "code": block.getFieldValue('METAL1'), "ratio": parseInt(block.getFieldValue('RATIO1')) }, { "code": block.getFieldValue('METAL2'), "ratio": 100 - parseInt(block.getFieldValue('RATIO1')) }], "output": block.getFieldValue('OUTPUT') };
            return JSON.stringify(json, null, 2) + '|||alloy|||';
        };

        Blockly.Blocks['vs_fuel_type'] = {
            init: function() {
                this.appendDummyInput().appendField("Brennstoff").appendField(new Blockly.FieldTextInput("myfuel", validateName), "NAME");
                this.appendDummyInput().appendField("Item").appendField(new Blockly.FieldTextInput("game:firewood", validateCode), "ITEM");
                this.appendDummyInput().appendField("Brenndauer (Sek.)").appendField(new Blockly.FieldNumber(60, 1, 3600), "DURATION");
                this.appendDummyInput().appendField("Temperatur").appendField(new Blockly.FieldNumber(800, 100, 2000), "TEMP");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_fuel_type'] = function(block) { return ''; };

        Blockly.Blocks['vs_drying_recipe'] = {
            init: function() {
                this.appendDummyInput().appendField("Trocknungsrezept").appendField(new Blockly.FieldTextInput("mydrying", validateName), "NAME");
                this.appendDummyInput().appendField("Eingabe").appendField(new Blockly.FieldTextInput("game:meat-raw", validateCode), "INPUT");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:meat-dried", validateCode), "OUTPUT");
                this.appendDummyInput().appendField("Dauer (Tage)").appendField(new Blockly.FieldNumber(3, 1, 30), "DAYS");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_drying_recipe'] = function(block) { return ''; };

        Blockly.Blocks['vs_grinding_recipe'] = {
            init: function() {
                this.appendDummyInput().appendField("Mahlstein-Rezept").appendField(new Blockly.FieldTextInput("mygrinding", validateName), "NAME");
                this.appendDummyInput().appendField("Eingabe").appendField(new Blockly.FieldTextInput("game:grain-wheat", validateCode), "INPUT");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:flour-wheat", validateCode), "OUTPUT");
                this.appendDummyInput().appendField("Menge").appendField(new Blockly.FieldNumber(1, 1, 16), "QUANTITY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(45);
            }
        };
        Blockly.JavaScript['vs_grinding_recipe'] = function(block) { return ''; };

        // ========== SOUNDS & PARTIKEL ==========
        Blockly.Blocks['vs_custom_sound'] = {
            init: function() {
                this.appendDummyInput().appendField("Eigener Sound").appendField(new Blockly.FieldTextInput("mysound", validateName), "NAME");
                this.appendDummyInput().appendField("Lautstärke").appendField(new Blockly.FieldNumber(1.0, 0.1, 2, 0.1), "VOLUME");
                this.appendDummyInput().appendField("Reichweite").appendField(new Blockly.FieldNumber(16, 1, 64), "RANGE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(195);
            }
        };
        Blockly.JavaScript['vs_custom_sound'] = function(block) { return ''; };

        Blockly.Blocks['vs_ambient_sound'] = {
            init: function() {
                this.appendDummyInput().appendField("Umgebungssound").appendField(new Blockly.FieldTextInput("myambient", validateName), "NAME");
                this.appendDummyInput().appendField("Sound").appendField(new Blockly.FieldTextInput("game:environment/wind", validateCode), "SOUND");
                this.appendDummyInput().appendField("Intervall (Sek.)").appendField(new Blockly.FieldNumber(30, 1, 600), "INTERVAL");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(195);
            }
        };
        Blockly.JavaScript['vs_ambient_sound'] = function(block) { return ''; };

        Blockly.Blocks['vs_particle_effect'] = {
            init: function() {
                this.appendDummyInput().appendField("Partikeleffekt").appendField(new Blockly.FieldTextInput("myparticle", validateName), "NAME");
                this.appendDummyInput().appendField("Typ").appendField(new Blockly.FieldDropdown([["Rauch","smoke"],["Feuer","fire"],["Funken","spark"],["Staub","dust"],["Wasser","water"],["Magie","magic"]]), "TYPE");
                this.appendDummyInput().appendField("Menge").appendField(new Blockly.FieldNumber(10, 1, 100), "QUANTITY");
                this.appendDummyInput().appendField("Lebensdauer (Sek.)").appendField(new Blockly.FieldNumber(2, 0.1, 30, 0.1), "LIFETIME");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(195);
            }
        };
        Blockly.JavaScript['vs_particle_effect'] = function(block) { return ''; };

        Blockly.Blocks['vs_block_particles'] = {
            init: function() {
                this.appendDummyInput().appendField("Block-Partikel").appendField(new Blockly.FieldTextInput("myblock", validateName), "BLOCK");
                this.appendDummyInput().appendField("Partikel").appendField(new Blockly.FieldDropdown([["Rauch","smoke"],["Funken","spark"],["Staub","dust"]]), "PARTICLE");
                this.appendDummyInput().appendField("Rate").appendField(new Blockly.FieldNumber(1, 0.1, 10, 0.1), "RATE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(195);
            }
        };
        Blockly.JavaScript['vs_block_particles'] = function(block) { return ''; };

        Blockly.Blocks['vs_weather_particles'] = {
            init: function() {
                this.appendDummyInput().appendField("Wetter-Partikel");
                this.appendDummyInput().appendField("Typ").appendField(new Blockly.FieldDropdown([["Regen","rain"],["Schnee","snow"],["Nebel","fog"],["Gewitter","thunder"]]), "TYPE");
                this.appendDummyInput().appendField("Intensität").appendField(new Blockly.FieldNumber(1, 0.1, 5, 0.1), "INTENSITY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(195);
            }
        };
        Blockly.JavaScript['vs_weather_particles'] = function(block) { return ''; };

        Blockly.Blocks['vs_footstep_sound'] = {
            init: function() {
                this.appendDummyInput().appendField("Schrittgeräusch für Block").appendField(new Blockly.FieldTextInput("myblock", validateName), "BLOCK");
                this.appendDummyInput().appendField("Sound").appendField(new Blockly.FieldDropdown([["Holz","wood"],["Stein","stone"],["Gras","grass"],["Metall","metal"],["Sand","sand"],["Kies","gravel"]]), "SOUND");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(195);
            }
        };
        Blockly.JavaScript['vs_footstep_sound'] = function(block) { return ''; };

        // ========== GUI & HUD ==========
        Blockly.Blocks['vs_custom_gui'] = {
            init: function() {
                this.appendDummyInput().appendField("Eigene GUI").appendField(new Blockly.FieldTextInput("mygui", validateName), "NAME");
                this.appendDummyInput().appendField("Breite").appendField(new Blockly.FieldNumber(400, 100, 1000), "WIDTH");
                this.appendDummyInput().appendField("Höhe").appendField(new Blockly.FieldNumber(300, 100, 800), "HEIGHT");
                this.appendDummyInput().appendField("Titel").appendField(new Blockly.FieldTextInput("Mein Dialog", validateText), "TITLE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(30);
            }
        };
        Blockly.JavaScript['vs_custom_gui'] = function(block) {
            var name = block.getFieldValue('NAME'), width = block.getFieldValue('WIDTH'), height = block.getFieldValue('HEIGHT'), title = block.getFieldValue('TITLE');
            var csharp = `
using Vintagestory.API.Client;
namespace ${modConfig.modName} {
    public class GuiDialog${name} : GuiDialog {
        public override string ToggleKeyCombinationCode => "${name}_dialog";
        public GuiDialog${name}(ICoreClientAPI capi) : base(capi) { SetupDialog(); }
        private void SetupDialog() {
            ElementBounds dialogBounds = ElementStdBounds.AutosizedMainDialog.WithAlignment(EnumDialogArea.CenterMiddle).WithFixedSize(${width}, ${height});
            ElementBounds bgBounds = ElementBounds.Fill.WithFixedPadding(10);
            SingleComposer = capi.Gui.CreateCompo("${name}_dialog", dialogBounds)
                .AddShadedDialogBG(bgBounds).AddDialogTitleBar("${title}", OnTitleBarClose).Compose();
        }
        private void OnTitleBarClose() { TryClose(); }
    }
}`;
            return 'csharp:GuiDialog' + name + ':' + csharp + '|||';
        };

        Blockly.Blocks['vs_hud_element'] = {
            init: function() {
                this.appendDummyInput().appendField("HUD Element").appendField(new Blockly.FieldTextInput("myhud", validateName), "NAME");
                this.appendDummyInput().appendField("Position X").appendField(new Blockly.FieldNumber(10, 0, 1920), "X");
                this.appendDummyInput().appendField("Position Y").appendField(new Blockly.FieldNumber(10, 0, 1080), "Y");
                this.appendDummyInput().appendField("Text").appendField(new Blockly.FieldTextInput("HUD Text", validateText), "TEXT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(30);
            }
        };
        Blockly.JavaScript['vs_hud_element'] = function(block) { return ''; };

        Blockly.Blocks['vs_progress_bar'] = {
            init: function() {
                this.appendDummyInput().appendField("Fortschrittsbalken").appendField(new Blockly.FieldTextInput("mybar", validateName), "NAME");
                this.appendDummyInput().appendField("Breite").appendField(new Blockly.FieldNumber(200, 50, 500), "WIDTH");
                this.appendDummyInput().appendField("Höhe").appendField(new Blockly.FieldNumber(20, 10, 100), "HEIGHT");
                this.appendDummyInput().appendField("Farbe").appendField(new Blockly.FieldDropdown([["Grün","green"],["Rot","red"],["Blau","blue"],["Gelb","yellow"]]), "COLOR");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(30);
            }
        };
        Blockly.JavaScript['vs_progress_bar'] = function(block) { return ''; };

        Blockly.Blocks['vs_inventory_slots'] = {
            init: function() {
                this.appendDummyInput().appendField("Inventar-Slots").appendField(new Blockly.FieldTextInput("myinv", validateName), "NAME");
                this.appendDummyInput().appendField("Spalten").appendField(new Blockly.FieldNumber(9, 1, 20), "COLS");
                this.appendDummyInput().appendField("Zeilen").appendField(new Blockly.FieldNumber(3, 1, 10), "ROWS");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(30);
            }
        };
        Blockly.JavaScript['vs_inventory_slots'] = function(block) { return ''; };

        Blockly.Blocks['vs_button_element'] = {
            init: function() {
                this.appendDummyInput().appendField("GUI Button").appendField(new Blockly.FieldTextInput("mybutton", validateName), "NAME");
                this.appendDummyInput().appendField("Text").appendField(new Blockly.FieldTextInput("Klick!", validateText), "TEXT");
                this.appendDummyInput().appendField("Breite").appendField(new Blockly.FieldNumber(100, 30, 300), "WIDTH");
                this.appendDummyInput().appendField("Aktion").appendField(new Blockly.FieldTextInput("ShowMessage", validateName), "ACTION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(30);
            }
        };
        Blockly.JavaScript['vs_button_element'] = function(block) { return ''; };

        Blockly.Blocks['vs_text_input'] = {
            init: function() {
                this.appendDummyInput().appendField("Texteingabe").appendField(new Blockly.FieldTextInput("myinput", validateName), "NAME");
                this.appendDummyInput().appendField("Platzhalter").appendField(new Blockly.FieldTextInput("Eingabe...", validateText), "PLACEHOLDER");
                this.appendDummyInput().appendField("Breite").appendField(new Blockly.FieldNumber(200, 50, 500), "WIDTH");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(30);
            }
        };
        Blockly.JavaScript['vs_text_input'] = function(block) { return ''; };

        Blockly.Blocks['vs_dropdown_menu'] = {
            init: function() {
                this.appendDummyInput().appendField("Dropdown").appendField(new Blockly.FieldTextInput("mydropdown", validateName), "NAME");
                this.appendDummyInput().appendField("Optionen").appendField(new Blockly.FieldTextInput("Option1,Option2,Option3", validateText), "OPTIONS");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(30);
            }
        };
        Blockly.JavaScript['vs_dropdown_menu'] = function(block) { return ''; };

        Blockly.Blocks['vs_tooltip'] = {
            init: function() {
                this.appendDummyInput().appendField("Tooltip für").appendField(new Blockly.FieldTextInput("myitem", validateName), "ITEM");
                this.appendDummyInput().appendField("Text").appendField(new Blockly.FieldTextInput("Dies ist ein Tooltip", validateText), "TEXT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(30);
            }
        };
        Blockly.JavaScript['vs_tooltip'] = function(block) { return ''; };

        // ========== COMMANDS & EVENTS ==========
        Blockly.Blocks['vs_chat_command'] = {
            init: function() {
                this.appendDummyInput().appendField("Chat-Befehl").appendField(new Blockly.FieldTextInput("mycommand", validateName), "NAME");
                this.appendDummyInput().appendField("Beschreibung").appendField(new Blockly.FieldTextInput("Mein Befehl", validateText), "DESC");
                this.appendDummyInput().appendField("Berechtigung").appendField(new Blockly.FieldDropdown([["Alle","0"],["Moderator","50"],["Admin","100"]]), "PERMISSION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210);
            }
        };
        Blockly.JavaScript['vs_chat_command'] = function(block) {
            var name = block.getFieldValue('NAME'), desc = block.getFieldValue('DESC'), perm = block.getFieldValue('PERMISSION');
            var csharp = `
using Vintagestory.API.Common;
using Vintagestory.API.Server;
namespace ${modConfig.modName} {
    public class Command${name} : ModSystem {
        public override void StartServerSide(ICoreServerAPI api) {
            api.ChatCommands.Create("${name}").WithDescription("${desc}").RequiresPrivilege(Privilege.chat)
                .HandleWith(args => { args.Caller.Player.SendMessage(0, "Befehl ${name} ausgeführt!", EnumChatType.Notification); return TextCommandResult.Success(); });
        }
    }
}`;
            return 'csharp:Command' + name + ':' + csharp + '|||';
        };

        Blockly.Blocks['vs_keybind'] = {
            init: function() {
                this.appendDummyInput().appendField("Tastenbelegung").appendField(new Blockly.FieldTextInput("mykey", validateName), "NAME");
                this.appendDummyInput().appendField("Taste").appendField(new Blockly.FieldDropdown([["F","F"],["G","G"],["H","H"],["J","J"],["K","K"],["L","L"],["R","R"],["T","T"],["Y","Y"],["U","U"]]), "KEY");
                this.appendDummyInput().appendField("Beschreibung").appendField(new Blockly.FieldTextInput("Meine Taste", validateText), "DESC");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210);
            }
        };
        Blockly.JavaScript['vs_keybind'] = function(block) { return ''; };

        Blockly.Blocks['vs_on_player_join'] = {
            init: function() {
                this.appendDummyInput().appendField("Wenn Spieler beitritt");
                this.appendDummyInput().appendField("Nachricht").appendField(new Blockly.FieldTextInput("Willkommen!", validateText), "MESSAGE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210);
            }
        };
        Blockly.JavaScript['vs_on_player_join'] = function(block) {
            var message = block.getFieldValue('MESSAGE');
            var csharp = `
using Vintagestory.API.Common;
using Vintagestory.API.Server;
namespace ${modConfig.modName} {
    public class PlayerJoinHandler : ModSystem {
        public override void StartServerSide(ICoreServerAPI api) {
            api.Event.PlayerJoin += (player) => { api.SendMessage(player, 0, "${message}", EnumChatType.Notification); };
        }
    }
}`;
            return 'csharp:PlayerJoinHandler:' + csharp + '|||';
        };

        Blockly.Blocks['vs_on_block_break'] = {
            init: function() {
                this.appendDummyInput().appendField("Wenn Block abgebaut");
                this.appendDummyInput().appendField("Block").appendField(new Blockly.FieldTextInput("game:stone", validateCode), "BLOCK");
                this.appendDummyInput().appendField("Aktion").appendField(new Blockly.FieldTextInput("Stein abgebaut!", validateText), "ACTION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210);
            }
        };
        Blockly.JavaScript['vs_on_block_break'] = function(block) { return ''; };

        Blockly.Blocks['vs_on_entity_death'] = {
            init: function() {
                this.appendDummyInput().appendField("Wenn Entity stirbt");
                this.appendDummyInput().appendField("Entity").appendField(new Blockly.FieldTextInput("game:wolf", validateCode), "ENTITY");
                this.appendDummyInput().appendField("Aktion").appendField(new Blockly.FieldTextInput("Wolf getötet!", validateText), "ACTION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210);
            }
        };
        Blockly.JavaScript['vs_on_entity_death'] = function(block) { return ''; };

        Blockly.Blocks['vs_on_item_use'] = {
            init: function() {
                this.appendDummyInput().appendField("Wenn Item benutzt");
                this.appendDummyInput().appendField("Item").appendField(new Blockly.FieldTextInput("game:stick", validateCode), "ITEM");
                this.appendDummyInput().appendField("Aktion").appendField(new Blockly.FieldTextInput("Item benutzt!", validateText), "ACTION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210);
            }
        };
        Blockly.JavaScript['vs_on_item_use'] = function(block) { return ''; };

        Blockly.Blocks['vs_timer_event'] = {
            init: function() {
                this.appendDummyInput().appendField("Timer Event").appendField(new Blockly.FieldTextInput("mytimer", validateName), "NAME");
                this.appendDummyInput().appendField("Intervall (ms)").appendField(new Blockly.FieldNumber(1000, 100, 60000), "INTERVAL");
                this.appendDummyInput().appendField("Aktion").appendField(new Blockly.FieldTextInput("Timer tick!", validateText), "ACTION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210);
            }
        };
        Blockly.JavaScript['vs_timer_event'] = function(block) { return ''; };

        Blockly.Blocks['vs_world_tick'] = {
            init: function() {
                this.appendDummyInput().appendField("Welt-Tick Handler").appendField(new Blockly.FieldTextInput("myworldtick", validateName), "NAME");
                this.appendDummyInput().appendField("Häufigkeit").appendField(new Blockly.FieldDropdown([["Jeden Tick","1"],["Alle 20 Ticks","20"],["Jede Sekunde","40"],["Alle 5 Sekunden","200"]]), "FREQUENCY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210);
            }
        };
        Blockly.JavaScript['vs_world_tick'] = function(block) { return ''; };

        // ========== MECHANIKEN & SYSTEME ==========
        Blockly.Blocks['vs_temperature_system'] = {
            init: function() {
                this.appendDummyInput().appendField("Temperatur System").appendField(new Blockly.FieldTextInput("mytemp", validateName), "NAME");
                this.appendDummyInput().appendField("Min. Temperatur").appendField(new Blockly.FieldNumber(-20, -100, 100), "MIN");
                this.appendDummyInput().appendField("Max. Temperatur").appendField(new Blockly.FieldNumber(40, -100, 100), "MAX");
                this.appendDummyInput().appendField("Schaden unter Min").appendField(new Blockly.FieldNumber(1, 0, 10, 0.5), "COLD_DAMAGE");
                this.appendDummyInput().appendField("Schaden über Max").appendField(new Blockly.FieldNumber(1, 0, 10, 0.5), "HEAT_DAMAGE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(270);
            }
        };
        Blockly.JavaScript['vs_temperature_system'] = function(block) { return ''; };

        Blockly.Blocks['vs_nutrition_type'] = {
            init: function() {
                this.appendDummyInput().appendField("Nährwert Typ").appendField(new Blockly.FieldTextInput("mynutrition", validateName), "NAME");
                this.appendDummyInput().appendField("Kategorie").appendField(new Blockly.FieldDropdown([["Protein","protein"],["Getreide","grain"],["Gemüse","vegetable"],["Obst","fruit"],["Milch","dairy"]]), "CATEGORY");
                this.appendDummyInput().appendField("Sättigung").appendField(new Blockly.FieldNumber(100, 1, 1000), "SATURATION");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(270);
            }
        };
        Blockly.JavaScript['vs_nutrition_type'] = function(block) { return ''; };

        Blockly.Blocks['vs_skill_system'] = {
            init: function() {
                this.appendDummyInput().appendField("Fähigkeit").appendField(new Blockly.FieldTextInput("myskill", validateName), "NAME");
                this.appendDummyInput().appendField("Max. Level").appendField(new Blockly.FieldNumber(100, 1, 1000), "MAX_LEVEL");
                this.appendDummyInput().appendField("XP pro Level").appendField(new Blockly.FieldNumber(100, 10, 10000), "XP_PER_LEVEL");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(270);
            }
        };
        Blockly.JavaScript['vs_skill_system'] = function(block) { return ''; };

        Blockly.Blocks['vs_experience_gain'] = {
            init: function() {
                this.appendDummyInput().appendField("XP Gewinn").appendField(new Blockly.FieldTextInput("myxp", validateName), "NAME");
                this.appendDummyInput().appendField("Aktion").appendField(new Blockly.FieldDropdown([["Block abbauen","mine"],["Kreatur töten","kill"],["Item herstellen","craft"],["Entdecken","explore"]]), "ACTION");
                this.appendDummyInput().appendField("XP Menge").appendField(new Blockly.FieldNumber(10, 1, 1000), "AMOUNT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(270);
            }
        };
        Blockly.JavaScript['vs_experience_gain'] = function(block) { return ''; };

        Blockly.Blocks['vs_status_effect'] = {
            init: function() {
                this.appendDummyInput().appendField("Status Effekt").appendField(new Blockly.FieldTextInput("myeffect", validateName), "NAME");
                this.appendDummyInput().appendField("Typ").appendField(new Blockly.FieldDropdown([["Buff","buff"],["Debuff","debuff"]]), "TYPE");
                this.appendDummyInput().appendField("Dauer (Sek.)").appendField(new Blockly.FieldNumber(30, 1, 600), "DURATION");
                this.appendDummyInput().appendField("Stärke").appendField(new Blockly.FieldNumber(1, 1, 10), "STRENGTH");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(270);
            }
        };
        Blockly.JavaScript['vs_status_effect'] = function(block) { return ''; };

        Blockly.Blocks['vs_damage_type'] = {
            init: function() {
                this.appendDummyInput().appendField("Schadenstyp").appendField(new Blockly.FieldTextInput("mydamage", validateName), "NAME");
                this.appendDummyInput().appendField("Typ").appendField(new Blockly.FieldDropdown([["Physisch","physical"],["Feuer","fire"],["Frost","frost"],["Gift","poison"],["Magie","magic"],["Fall","fall"]]), "TYPE");
                this.appendDummyInput().appendField("Basis Schaden").appendField(new Blockly.FieldNumber(5, 0.5, 100, 0.5), "DAMAGE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(270);
            }
        };
        Blockly.JavaScript['vs_damage_type'] = function(block) { return ''; };

        Blockly.Blocks['vs_repair_system'] = {
            init: function() {
                this.appendDummyInput().appendField("Reparatur System").appendField(new Blockly.FieldTextInput("myrepair", validateName), "NAME");
                this.appendDummyInput().appendField("Item").appendField(new Blockly.FieldTextInput("game:pickaxe-iron", validateCode), "ITEM");
                this.appendDummyInput().appendField("Material").appendField(new Blockly.FieldTextInput("game:ingot-iron", validateCode), "MATERIAL");
                this.appendDummyInput().appendField("Reparatur %").appendField(new Blockly.FieldNumber(25, 1, 100), "REPAIR_PERCENT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(270);
            }
        };
        Blockly.JavaScript['vs_repair_system'] = function(block) { return ''; };

        Blockly.Blocks['vs_decay_system'] = {
            init: function() {
                this.appendDummyInput().appendField("Verfall System").appendField(new Blockly.FieldTextInput("mydecay", validateName), "NAME");
                this.appendDummyInput().appendField("Item").appendField(new Blockly.FieldTextInput("game:meat-raw", validateCode), "ITEM");
                this.appendDummyInput().appendField("Verfallszeit (Tage)").appendField(new Blockly.FieldNumber(7, 1, 365), "DAYS");
                this.appendDummyInput().appendField("Ergebnis").appendField(new Blockly.FieldTextInput("game:rot", validateCode), "RESULT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(270);
            }
        };
        Blockly.JavaScript['vs_decay_system'] = function(block) { return ''; };

        // ========== ERWEITERTE BLÖCKE ==========
        Blockly.Blocks['vs_liquid_block'] = {
            init: function() {
                this.appendDummyInput().appendField("Flüssigkeit").appendField(new Blockly.FieldTextInput("myliquid", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Fließgeschw.").appendField(new Blockly.FieldNumber(5, 1, 20), "FLOW_SPEED");
                this.appendDummyInput().appendField("Viskosität").appendField(new Blockly.FieldNumber(1, 0.1, 10, 0.1), "VISCOSITY");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_liquid_block'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "BlockLiquid", "drawtype": "Liquid", "replaceable": 6000, "liquidCode": name, "pushVector": { "x": 0, "y": -0.1, "z": 0 }, "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/water" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_plant_block'] = {
            init: function() {
                this.appendDummyInput().appendField("Pflanze").appendField(new Blockly.FieldTextInput("myplant", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Wachstumsstadien").appendField(new Blockly.FieldNumber(4, 1, 10), "STAGES");
                this.appendDummyInput().appendField("Wachstumszeit (Tage)").appendField(new Blockly.FieldNumber(7, 1, 60), "GROWTH_DAYS");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_plant_block'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE'), stages = block.getFieldValue('STAGES');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "BlockPlant", "drawtype": "Cross", "renderPass": "OpaqueNoCull", "stages": parseInt(stages), "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/plant" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_crop_block'] = {
            init: function() {
                this.appendDummyInput().appendField("Feldfrucht").appendField(new Blockly.FieldTextInput("mycrop", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Ertrag").appendField(new Blockly.FieldTextInput("game:grain-wheat", validateCode), "YIELD");
                this.appendDummyInput().appendField("Menge").appendField(new Blockly.FieldNumber(3, 1, 20), "YIELD_AMOUNT");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_crop_block'] = function(block) { return ''; };

        Blockly.Blocks['vs_door_block'] = {
            init: function() {
                this.appendDummyInput().appendField("Tür").appendField(new Blockly.FieldTextInput("mydoor", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Material").appendField(new Blockly.FieldDropdown([["Holz","wood"],["Eisen","iron"],["Bronze","bronze"]]), "MATERIAL");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_door_block'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "BlockDoor", "drawtype": "JSON", "behaviors": [{ "name": "Door" }], "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/door" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_container_block'] = {
            init: function() {
                this.appendDummyInput().appendField("Container").appendField(new Blockly.FieldTextInput("mycontainer", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Slots").appendField(new Blockly.FieldNumber(16, 1, 64), "SLOTS");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_container_block'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE'), slots = block.getFieldValue('SLOTS');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "BlockGenericTypedContainer", "entityClass": "GenericTypedContainer", "variantGroups": [{ "code": "type", "states": ["normal"] }], "attributes": { "inventoryClassName": name, "quantitySlots": parseInt(slots) }, "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/chest" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_light_source'] = {
            init: function() {
                this.appendDummyInput().appendField("Lichtquelle").appendField(new Blockly.FieldTextInput("mylight", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Lichtstärke").appendField(new Blockly.FieldNumber(15, 1, 32), "LIGHT_LEVEL");
                this.appendDummyInput().appendField("Farbe").appendField(new Blockly.FieldDropdown([["Weiß","white"],["Gelb","yellow"],["Orange","orange"],["Rot","red"],["Blau","blue"],["Grün","green"]]), "COLOR");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_light_source'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE'), lightLevel = block.getFieldValue('LIGHT_LEVEL');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "Block", "lightHsv": [parseInt(lightLevel), 0, parseInt(lightLevel)], "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/torch" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_rotatable_block'] = {
            init: function() {
                this.appendDummyInput().appendField("Drehbarer Block").appendField(new Blockly.FieldTextInput("myrotatable", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Achsen").appendField(new Blockly.FieldDropdown([["Horizontal","y"],["Alle","xyz"],["Nur vertikal","x"]]), "AXIS");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_rotatable_block'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "Block", "behaviors": [{ "name": "HorizontalOrientable" }], "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/stone" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_slab_stairs'] = {
            init: function() {
                this.appendDummyInput().appendField("Stufe/Platte").appendField(new Blockly.FieldTextInput("myslab", validateName), "NAME");
                this.appendDummyInput().appendField("Typ").appendField(new Blockly.FieldDropdown([["Platte","slab"],["Stufe","stair"]]), "TYPE");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_slab_stairs'] = function(block) {
            var name = block.getFieldValue('NAME'), type = block.getFieldValue('TYPE'), texture = block.getFieldValue('TEXTURE');
            var json = { "code": `${modConfig.modName}:${name}`, "class": type === "slab" ? "BlockSlab" : "BlockStairs", "drawtype": "JSON", "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/stone" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_falling_block'] = {
            init: function() {
                this.appendDummyInput().appendField("Fallender Block").appendField(new Blockly.FieldTextInput("myfalling", validateName), "NAME");
                this.appendDummyInput().appendField("Textur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Fallschaden").appendField(new Blockly.FieldCheckbox("TRUE"), "DAMAGE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_falling_block'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "BlockFalling", "behaviors": [{ "name": "Unstable" }], "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/sand" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        Blockly.Blocks['vs_connected_textures'] = {
            init: function() {
                this.appendDummyInput().appendField("Verbundene Texturen").appendField(new Blockly.FieldTextInput("myconnected", validateName), "NAME");
                this.appendDummyInput().appendField("Basistextur").appendField(new Blockly.FieldDropdown(getTextureOptions), "TEXTURE");
                this.appendDummyInput().appendField("Verbindungstyp").appendField(new Blockly.FieldDropdown([["Gleicher Block","same"],["Gleiche Gruppe","group"],["Alle","all"]]), "CONNECT_TYPE");
                this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120);
            }
        };
        Blockly.JavaScript['vs_connected_textures'] = function(block) {
            var name = block.getFieldValue('NAME'), texture = block.getFieldValue('TEXTURE');
            var json = { "code": `${modConfig.modName}:${name}`, "class": "Block", "drawtype": "Cube", "textureconnect": true, "texture": { "base": texture !== "none" ? `block/${path.basename(texture, '.png')}` : "game:block/glass" } };
            return JSON.stringify(json, null, 2) + '|||';
        };

        document.getElementById('output').innerText = "Blockly erfolgreich initialisiert. 80+ Blöcke verfügbar!";
    } catch (err) {
        document.getElementById('output').innerText = `Fehler beim Laden von Blockly: ${err.message}`;
    }

    function selectTexture() {
        ipcRenderer.send('select-texture');
    }

    ipcRenderer.on('texture-selected', (event, filePath) => {
        selectedTexturePath = filePath;
        textureList.push(filePath);
        updateTextureList();
        document.getElementById('texturePath').value = filePath;
    });

    ipcRenderer.on('texture-error', (event, errorMessage) => {
        document.getElementById('output').innerText = `Fehler bei Dateiauswahl: ${errorMessage}`;
    });

    function updateTextureList() {
        const textureDiv = document.getElementById('textureList');
        textureDiv.innerHTML = "Geladene Texturen:<br>";
        textureList.forEach((texture, index) => {
            textureDiv.innerHTML += `Textur ${index + 1}: ${path.basename(texture)}<br>`;
        });
    }

    function checkPrerequisites() {
        let outputText = '';
        try {
            outputText += `Aktueller Wert von VINTAGE_STORY: ${process.env.VINTAGE_STORY}\n`;
            const sdkCheck = execSync('dotnet --list-sdks', { encoding: 'utf8' });
            if (!sdkCheck.includes('7.0')) {
                throw new Error('.NET 7.0 SDK ist nicht installiert. Bitte installiere es von der offiziellen .NET-Website.');
            }
            outputText += '.NET 7.0 SDK gefunden:\n' + sdkCheck + '\n';
            let vsPath = process.env.VINTAGE_STORY;
            if (!vsPath) {
                throw new Error('Umgebungsvariable VINTAGE_STORY nicht gesetzt.');
            }
            outputText += `Normalisierter Pfad: ${vsPath}\n`;
            vsPath = path.normalize(vsPath).replace(/\//g, '\\');
            if (!fs.existsSync(vsPath)) {
                throw new Error(`Verzeichnis nicht gefunden: ${vsPath}`);
            }
            outputText += `Verzeichnis existiert: ${vsPath}\n`;
            let vsExe = path.join(vsPath, 'Vintagestory.exe');
            let vsLibDll = path.join(vsPath, 'Vintagestory.dll');
            let vsApiDll = path.join(vsPath, 'VintagestoryAPI.dll');
            if (!fs.existsSync(vsExe)) {
                vsExe = path.join(vsPath, 'bin', 'Vintagestory.exe');
                if (!fs.existsSync(vsExe)) {
                    throw new Error(`Vintagestory.exe nicht gefunden unter: ${path.join(vsPath, 'Vintagestory.exe')} oder ${vsExe}`);
                }
            }
            if (!fs.existsSync(vsLibDll)) {
                vsLibDll = path.join(vsPath, 'Lib', 'Vintagestory.dll');
                if (!fs.existsSync(vsLibDll)) {
                    vsLibDll = path.join(vsPath, 'bin', 'Lib', 'Vintagestory.dll');
                    if (!fs.existsSync(vsLibDll)) {
                        throw new Error(`Vintagestory.dll nicht gefunden unter: ${path.join(vsPath, 'Vintagestory.dll')}, ${path.join(vsPath, 'Lib', 'Vintagestory.dll')} oder ${vsLibDll}`);
                    }
                }
            }
            if (!fs.existsSync(vsApiDll)) {
                vsApiDll = path.join(vsPath, 'Lib', 'VintagestoryAPI.dll');
                if (!fs.existsSync(vsApiDll)) {
                    vsApiDll = path.join(vsPath, 'bin', 'Lib', 'VintagestoryAPI.dll');
                    if (!fs.existsSync(vsApiDll)) {
                        throw new Error(`VintagestoryAPI.dll nicht gefunden unter: ${path.join(vsPath, 'VintagestoryAPI.dll')}, ${path.join(vsPath, 'Lib', 'VintagestoryAPI.dll')} oder ${vsApiDll}`);
                    }
                }
            }
            outputText += `Vintagestory.exe gefunden: ${vsExe}\n`;
            outputText += `Vintagestory.dll gefunden: ${vsLibDll}\n`;
            outputText += `VintagestoryAPI.dll gefunden: ${vsApiDll}\n`;
            return { success: true, message: outputText, vsPath };
        } catch (err) {
            return { success: false, message: `Fehler bei Voraussetzungen: ${err.message}` };
        }
    }

    function generateModSystemCode(blockClassMap, behaviorMap) {
        let code = `
using Vintagestory.API.Common;
using Vintagestory.API.Datastructures;

namespace ${modConfig.modName} {
    public class ${modConfig.modName} : ModSystem {
        public override void StartPre(ICoreAPI api) {
            base.StartPre(api);
            api.Logger.Notification("${modConfig.modName}: StartPre called - Registering classes...");
`;

        for (const blockName in blockClassMap) {
            const className = blockClassMap[blockName];
            code += `
            api.RegisterBlockClass("${className}", typeof(Block${blockName}));
            api.Logger.Notification("${modConfig.modName}: ${className} class registered!");
`;
        }

        for (const blockName in behaviorMap) {
            code += `
            api.RegisterBlockBehaviorClass("${modConfig.modName}.Behavior${blockName}", typeof(Behavior${blockName}));
            api.Logger.Notification("${modConfig.modName}: Behavior${blockName} behavior registered!");
`;
        }

        code += `
        }

        public override void Start(ICoreAPI api) {
            base.Start(api);
            api.Logger.Notification("${modConfig.modName} geladen!");
        }
    }
}
`;
        return code;
    }

    function generateCsprojContent(vsPath) {
        return `
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <AssemblyName>${modConfig.modName}</AssemblyName>
    <OutputType>Library</OutputType>
    <RootNamespace>${modConfig.modName}</RootNamespace>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Vintagestory">
      <HintPath>${path.join(vsPath, 'Vintagestory.dll')}</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="VintagestoryAPI">
      <HintPath>${path.join(vsPath, 'VintagestoryAPI.dll')}</HintPath>
      <Private>false</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="System.Collections.Immutable" Version="8.0.0" />
  </ItemGroup>
</Project>`;
    }

    function sanitizeFileName(name) {
        return name.replace(/[^a-zA-Z0-9-_]/g, '');
    }

    function generateMod() {
        if (!/^[a-zA-Z0-9-_]+$/.test(modConfig.modName)) {
            throw new Error("Ungültiger Mod-Name: Nur Buchstaben, Zahlen, Bindestriche und Unterstriche sind erlaubt.");
        }

        const logFilePath = path.join(__dirname, `${sanitizeFileName(modConfig.modName)}_creation.log`);
        fs.writeFileSync(logFilePath, '', 'utf8');

        let outputText = '';
        let blockClassMap = {};
        let behaviorMap = {};

        try {
            outputText += `Aktuelles Arbeitsverzeichnis: ${process.cwd()}\n`;
            const prereqCheck = checkPrerequisites();
            outputText += prereqCheck.message;
            if (!prereqCheck.success) throw new Error(prereqCheck.message);
            const vsPath = prereqCheck.vsPath;

            outputText += `Verwendete Pfade für .csproj:\n`;
            outputText += `- Vintagestory.dll: ${path.join(vsPath, 'Vintagestory.dll')}\n`;
            outputText += `- VintagestoryAPI.dll: ${path.join(vsPath, 'VintagestoryAPI.dll')}\n`;

            const vsDllPath = path.join(vsPath, 'Vintagestory.dll');
            const vsApiDllPath = path.join(vsPath, 'VintagestoryAPI.dll');
            outputText += `Dateiexistenz prüfen:\n`;
            outputText += `- Vintagestory.dll existiert: ${fs.existsSync(vsDllPath)}\n`;
            outputText += `- VintagestoryAPI.dll existiert: ${fs.existsSync(vsApiDllPath)}\n`;

            const rawCode = Blockly.JavaScript.workspaceToCode(workspace);
            outputText += `Raw Code:\n${rawCode}\n\n`;

            const items = rawCode.split('|||').filter(item => item.trim() !== '');
            outputText += `Items nach Split:\n${JSON.stringify(items, null, 2)}\n\n`;

            const tempDir = path.join(__dirname, 'temp');
            const finalZip = new AdmZip();
            let hasCSharp = false;
            let behaviors = [];

            if (fs.existsSync(tempDir)) fs.rmSync(tempDir, { recursive: true });
            fs.mkdirSync(tempDir);
            outputText += "Temp-Ordner erstellt.\n";

            const modinfo = {
                "type": items.some(item => item.startsWith('csharp:')) ? "code" : "content",
                "modid": modConfig.modName,
                "name": modConfig.modName,
                "authors": [modConfig.author],
                "description": modConfig.description,
                "version": modConfig.version,
                "dependencies": modConfig.dependencies
            };
            const modinfoPath = path.join(tempDir, 'modinfo.json');
            fs.writeFileSync(modinfoPath, JSON.stringify(modinfo, null, 2) + '\n', 'utf8');
            outputText += `modinfo.json erstellt:\n${fs.readFileSync(modinfoPath, 'utf8')}\n`;

            outputText += "Starte Blockname-Extraktion...\n";
            items.forEach((item, index) => {
                outputText += `Verarbeite Item ${index}: ${item.slice(0, 50)}...\n`;
                if (!item.startsWith('json:') && !item.startsWith('csharp:') && item.trim()) {
                    try {
                        const json = JSON.parse(item.trim());
                        outputText += `JSON geparst: ${JSON.stringify(json, null, 2)}\n`;
                        if (json.class && json.class.startsWith(`${modConfig.modName}.Block`) && json.class.split('.').length === 2) {
                            const blockName = json.class.split('.')[1].substring(5);
                            blockClassMap[blockName] = json.class;
                            outputText += `Blockname extrahiert: ${blockName}\n`;
                        } else {
                            outputText += "Keine gültige Block-Klasse gefunden.\n";
                        }
                    } catch (e) {
                        outputText += `Warnung: Ungültiges JSON-Element übersprungen: ${e.message}\n`;
                    }
                }
            });

            items.forEach((item, index) => {
                if (item.startsWith('json:')) {
                    const behaviorJson = JSON.parse(item.replace('json:', ''));
                    const behaviorName = behaviorJson.name.split('.').pop().substring(8);
                    if (blockClassMap[behaviorName]) {
                        behaviors.push(behaviorJson);
                        behaviorMap[behaviorName] = true;
                        outputText += `Verhalten ${behaviorName} wird Block ${behaviorName} zugewiesen.\n`;
                    } else {
                        outputText += `Verhalten ${behaviorName} hat keinen passenden Block und wird ignoriert.\n`;
                    }
                }
            });

            items.forEach((item, index) => {
                if (item.startsWith('json:')) {
                } else if (item.startsWith('csharp:')) {
                    hasCSharp = true;
                    const parts = item.split(':');
                    const name = parts[1];
                    const csharpCode = parts.slice(2).join(':').trim();
                    fs.mkdirSync(path.join(tempDir, 'src'), { recursive: true });
                    fs.writeFileSync(path.join(tempDir, 'src', `${sanitizeFileName(name)}.cs`), csharpCode);
                    outputText += `C#-Datei erstellt: src/${sanitizeFileName(name)}.cs\n`;
                    outputText += `Inhalt von src/${sanitizeFileName(name)}.cs:\n${csharpCode}\n\n`;
                } else {
                    const json = JSON.parse(item.trim());
                    if (json.class && (json.class.startsWith(`${modConfig.modName}.Block`) || json.class === "Block")) {
                        fs.mkdirSync(path.join(tempDir, `assets/${modConfig.modName}/blocktypes`), { recursive: true });
                        const blockNameFromClass = json.class.split('.').length > 1 ? json.class.split('.')[1].substring(5) : json.code.split(':')[1];
                        if (behaviors.length > 0) {
                            outputText += `Prüfe Verhalten für Block ${blockNameFromClass}:\n`;
                            outputText += `Verfügbare Verhalten: ${JSON.stringify(behaviors, null, 2)}\n`;
                            json.behaviors = behaviors.filter(b => {
                                const behaviorBlockName = b.name.split('.').pop().substring(8);
                                outputText += `Vergleiche: ${behaviorBlockName} mit ${blockNameFromClass}\n`;
                                return behaviorBlockName === blockNameFromClass;
                            });
                            outputText += `Zugewiesene Verhalten: ${JSON.stringify(json.behaviors, null, 2)}\n`;
                        }
                        const blockFilePath = path.join(tempDir, `assets/${modConfig.modName}/blocktypes`, `${sanitizeFileName(json.code.split(':')[1])}.json`);
                        fs.writeFileSync(blockFilePath, JSON.stringify(json, null, 2));
                        outputText += `Block-Datei erstellt: assets/${modConfig.modName}/blocktypes/${sanitizeFileName(json.code.split(':')[1])}.json\n`;
                    } else if (json.ingredientPattern) {
                        fs.mkdirSync(path.join(tempDir, `assets/${modConfig.modName}/recipes`), { recursive: true });
                        fs.writeFileSync(path.join(tempDir, `assets/${modConfig.modName}/recipes`, `${sanitizeFileName(json.output.code.split(':')[1])}_recipe.json`), JSON.stringify(json, null, 2));
                        outputText += `Rezept-Datei erstellt: assets/${modConfig.modName}/recipes/${sanitizeFileName(json.output.code.split(':')[1])}_recipe.json\n`;
                    }
                }
            });

            if (textureList.length > 0) {
                const textureDir = path.join(tempDir, `assets/${modConfig.modName}/textures/block`);
                fs.mkdirSync(textureDir, { recursive: true });
                textureList.forEach(texture => {
                    const textureFile = path.join(textureDir, path.basename(texture));
                    fs.copyFileSync(texture, textureFile);
                    outputText += `Textur kopiert: assets/${modConfig.modName}/textures/block/${path.basename(texture)}\n`;
                });
            }

            if (hasCSharp) {
                const modSystemCode = generateModSystemCode(blockClassMap, behaviorMap);
                fs.writeFileSync(path.join(tempDir, 'src', 'Mod.cs'), modSystemCode);
                outputText += "C#-ModSystem erstellt: src/Mod.cs\n";
                outputText += `Inhalt von src/Mod.cs:\n${modSystemCode}\n\n`;

                const csprojContent = generateCsprojContent(vsPath);
                fs.writeFileSync(path.join(tempDir, `${sanitizeFileName(modConfig.modName)}.csproj`), csprojContent);
                outputText += `${sanitizeFileName(modConfig.modName)}.csproj erstellt:\n` + fs.readFileSync(path.join(tempDir, `${sanitizeFileName(modConfig.modName)}.csproj`), 'utf8') + "\n";

                const buildDir = path.join(tempDir, 'bin', 'Release', 'net7.0');
                try {
                    const buildCommand = `dotnet build "${path.join(tempDir, `${sanitizeFileName(modConfig.modName)}.csproj`)}" -c Release -o "${buildDir}" -v normal`;
                    outputText += `Starte Kompilierung mit Befehl: ${buildCommand}\n`;
                    outputText += `--------------------------------\n`;
                    const buildOutput = execSync(buildCommand, { encoding: 'utf8' });
                    outputText += `--------------------------------\n`;
                    outputText += `C#-Code kompiliert zu ${sanitizeFileName(modConfig.modName)}.dll.\n`;
                    outputText += `Build-Ausgabe:\n${buildOutput}\n`;
                } catch (buildError) {
                    outputText += `--------------------------------\n`;
                    outputText += `Kompilierungsfehler:\n`;
                    outputText += `stdout:\n${buildError.stdout}\n`;
                    outputText += `stderr:\n${buildError.stderr}\n`;
                    outputText += `--------------------------------\n`;
                    throw new Error("Kompilierung fehlgeschlagen.");
                }
            }

            finalZip.addLocalFile(modinfoPath);
            outputText += "modinfo.json zur ZIP hinzugefügt.\n";

            const assetsDir = path.join(tempDir, 'assets');
            if (fs.existsSync(assetsDir)) {
                finalZip.addLocalFolder(assetsDir, 'assets');
                outputText += "assets/ zur ZIP hinzugefügt.\n";
            }

            const dllPath = path.join(tempDir, 'bin', 'Release', 'net7.0', `${sanitizeFileName(modConfig.modName)}.dll`);
            if (fs.existsSync(dllPath)) {
                finalZip.addLocalFile(dllPath);
                outputText += `${sanitizeFileName(modConfig.modName)}.dll zur ZIP hinzugefügt.\n`;
            } else if (hasCSharp) {
                throw new Error(`Kompilierung fehlgeschlagen: ${sanitizeFileName(modConfig.modName)}.dll nicht gefunden.`);
            }

            const outputZipPath = path.join(__dirname, `${sanitizeFileName(modConfig.modName)}.zip`);
            finalZip.writeZip(outputZipPath);
            outputText += `Mod erstellt: ${outputZipPath}\nFüge es in %appdata%/VintagestoryData/Mods ein.\n`;
            outputText += `Log-Datei ist verfügbar unter: ${logFilePath}\n`;

        } catch (err) {
            outputText += `Fehler: ${err.message}\nStack: ${err.stack}\n`;
        } finally {
            fs.appendFileSync(logFilePath, outputText, 'utf8');
            document.getElementById('output').innerText = outputText;
            const tempDir = path.join(__dirname, 'temp');
            if (fs.existsSync(tempDir)) fs.rmSync(tempDir, { recursive: true });
        }
    }

    ipcRenderer.on('load-workspace', (event, config) => {
        modConfig = {
            modName: config.modName || 'mymod2',
            author: config.author || 'Mod-Creator User',
            version: config.version || '1.0.0',
            description: config.description || 'Erstellt mit dem Vintage Story Mod-Creator',
            dependencies: config.dependencies || { 'game': '*' }
        };
        if (config.filePath) {
            try {
                const workspaceData = fs.readFileSync(config.filePath, 'utf8');
                const parsedData = JSON.parse(workspaceData);
                Blockly.serialization.workspaces.load(parsedData.workspace, workspace);
                document.getElementById('output').innerText = `Workspace geladen von: ${config.filePath}\nMod-Name: ${modConfig.modName}`;
            } catch (err) {
                document.getElementById('output').innerText = `Fehler beim Laden des Workspaces: ${err.message}`;
            }
        } else {
            document.getElementById('output').innerText = `Neuer Workspace erstellt mit Mod-Name: ${modConfig.modName}`;
        }
    });

    function saveWorkspace() {
        const workspaceData = {
            workspace: Blockly.serialization.workspaces.save(workspace),
            modConfig: modConfig
        };
        dialog.showSaveDialog({
            title: "Workspace speichern",
            defaultPath: path.join(__dirname, `${modConfig.modName}.json`),
            filters: [{ name: 'JSON Files', extensions: ['json'] }]
        }).then(result => {
            if (!result.canceled && result.filePath) {
                fs.writeFileSync(result.filePath, JSON.stringify(workspaceData, null, 2));
                document.getElementById('output').innerText = `Workspace gespeichert unter: ${result.filePath}`;
            }
        }).catch(err => {
            document.getElementById('output').innerText = `Fehler beim Speichern: ${err.message}`;
        });
    }

    document.querySelector('.controls').insertAdjacentHTML('beforeend', '<button onclick="saveWorkspace()">Workspace speichern</button>');
    </script>
</body>
</html>
